use std::collections::HashMap;

use rand::Rng;
use wasm_bindgen::prelude::*;

// types
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Cell {
    pub mass: u16,
    pub accel_magnitude: f32,
    pub accel_degrees: f32,
    // Cells have an x and y position that is not stored here.
    // It is generated by looking that the cell's index in the galaxy.
}

// types
#[wasm_bindgen]
pub struct Galaxy {
    size: u16,
    cells: Vec<Cell>,
    min_star_mass: u16,
}

// defaults
impl Galaxy {
    // --------------------------------------------------------------- //
    // An explanation of the mechanics of the different types of cells //
    // --------------------------------------------------------------- //

    // Nebula
    // Nebulas are the most common type of cell. It is the default type.
    // Nebulas gravitate towards each other, but do not naturally diffuse.
    // Nebulas can by created by stellar wind (e.g. from a star or white hole).

    // Planet
    // Planets are created by the aggregation of gas.
    // Planets here are understood to be gas giants, hot jupiters, and proto stars.
    // Planets do not gravitate towards gases.
    // Planets do not diffuse.

    // Star
    // Stars are created by aggregating gas around a planet.
    // Stars gravitate towards each other and planets.
    // Stars diffuse at a medium rate.

    // White Hole
    // White holes are created by the aggregation of stars.
    // White holes do not experience gravitation.
    // White holes diffuse at an incredible rate.
    // White holes exist to repel objects away from the max mass (eg. u16 max size).

    pub const TYPE_INDEX_GAS: u8 = 0;
    pub const TYPE_INDEX_PLANET: u8 = 1;
    pub const TYPE_INDEX_STAR: u8 = 2;
    pub const TYPE_INDEX_WHITE_HOLE: u8 = 3;
    pub const STAR_MAX_MASS: u16 = u16::MAX / 2;
}

impl Galaxy {
    // https://en.wikipedia.org/wiki/Newton%27s_law_of_universal_gravitation
    pub const GRAVATIONAL_CONSTANT: f32 = 0.0000000000667408;
}

// public methods
#[wasm_bindgen]
impl Galaxy {
    #[wasm_bindgen(constructor)]
    pub fn new(size: u16, cell_initial_mass: u16, min_star_mass: u16) -> Galaxy {
        // create a new galaxy
        // https://github.com/rustwasm/console_error_panic_hook#readme
        console_error_panic_hook::set_once();
        return Galaxy {
            size,
            min_star_mass,
            cells: vec![
                Cell {
                    mass: cell_initial_mass,
                    accel_magnitude: 0.0,
                    accel_degrees: 0.0,
                };
                (size as u32).pow(2) as usize
            ],
        };
    }
    pub fn seed(&self, additional: u16) -> Galaxy {
        // add mass to the galaxy
        let mut rng = rand::thread_rng();
        let next: Vec<Cell> = (0..self.size.pow(2))
            .map(|index| {
                let mass = self.cells[index as usize].mass;
                Cell {
                    mass: mass + rng.gen_range(0..additional + 1),
                    accel_magnitude: 0.0,
                    accel_degrees: 0.0,
                }
            })
            .collect();
        return Galaxy {
            size: self.size,
            cells: next,
            min_star_mass: self.min_star_mass,
        };
    }
    pub fn tick(&self, time: f32) -> Galaxy {
        // advance the galaxy one tick
        let with_gravitation: Vec<Cell> = (0..self.size.pow(2))
            .map(|index| {
                let _cell = self.cells[index as usize];
                let _neighbours = self.neighbours(index, u16::MAX);
                let (magnitude, degrees) = self.gravitate(index, _neighbours);
                Cell {
                    mass: _cell.mass,
                    accel_magnitude: magnitude,
                    accel_degrees: degrees,
                }
            })
            .collect();
        let after_acceleration = self.apply_acceleration(with_gravitation, time);
        return Galaxy {
            size: self.size,
            cells: after_acceleration,
            min_star_mass: self.min_star_mass,
        };
    }
    pub fn mass(&self) -> Vec<u16> {
        return self.cells.iter().map(|cell| cell.mass).collect();
    }
    pub fn x(&self) -> Vec<u16> {
        return (0..self.size.pow(2))
            .map(|index| self.index_to_row_col(index).0)
            .collect();
    }
    pub fn y(&self) -> Vec<u16> {
        return (0..self.size.pow(2))
            .map(|index| self.index_to_row_col(index).1)
            .collect();
    }
}

// private methods
impl Galaxy {
    fn star_reach_range(&self) -> u16 {
        return self.size;
    }
    fn gas_reach_range(&self) -> u16 {
        return (self.size as f32).sqrt() as u16;
    }
    fn reach_of_type(&self, type_index: u8) -> u16 {
        match type_index {
            Galaxy::TYPE_INDEX_STAR => self.star_reach_range(),
            Galaxy::TYPE_INDEX_GAS => self.gas_reach_range(),
            _ => unreachable!(),
        }
    }
    fn get_type_index(&self, cell: Cell) -> u8 {
        if cell.mass < self.min_star_mass {
            return Galaxy::TYPE_INDEX_GAS;
        } else {
            return Galaxy::TYPE_INDEX_STAR;
        }
    }
    fn check_if_type(&self, cell: Cell, type_index: u8) -> bool {
        let this_type_index = self.get_type_index(cell);
        return type_index == this_type_index;
    }
    fn neighbours_of_my_type(&self, index: u16) -> Vec<(u16, u16)> {
        let type_index = self.get_type_index(self.cells[index as usize]);
        return self.neighbours_of_type(index, type_index);
    }
    fn neighbours_of_type(&self, index: u16, type_index: u8) -> Vec<(u16, u16)> {
        let mut neighbours_of_type = Vec::new();
        for neighbour in self.neighbours(index, self.reach_of_type(type_index)) {
            if self.check_if_type(self.cells[index as usize], type_index) {
                neighbours_of_type.push(neighbour);
            }
        }
        return neighbours_of_type;
    }
    fn neighbours(&self, index: u16, reach: u16) -> Vec<(u16, u16)> {
        let mut neighbours = Vec::new();
        let (index_row, index_col) = self.index_to_row_col(index);
        let (row_start, row_end) = self.reach_range(index_row, reach);
        let (col_start, col_end) = self.reach_range(index_col, reach);
        for row in row_start..=row_end {
            for col in col_start..=col_end {
                if (row, col) != (index_row, index_col) {
                    neighbours.push((row, col));
                }
            }
        }
        return neighbours;
    }
    fn col_row_to_index(&self, col: u16, row: u16) -> u16 {
        return row * self.size + col;
    }
    fn index_to_row_col(&self, index: u16) -> (u16, u16) {
        return (index % self.size, index / self.size);
    }
    fn reach_range(&self, index: u16, reach: u16) -> (u16, u16) {
        return (
            self.reach_range_start(index, reach),
            self.reach_range_end(index, reach),
        );
    }
    fn reach_range_start(&self, index: u16, reach: u16) -> u16 {
        let start;
        if index < reach {
            start = 0;
        } else {
            start = index - reach;
        }
        return start;
    }
    fn reach_range_end(&self, index: u16, reach: u16) -> u16 {
        let end;
        if index.saturating_add(reach) >= self.size {
            end = self.size - 1;
        } else {
            end = index + reach;
        }
        return end;
    }
}

impl Galaxy {
    fn apply_acceleration(&self, cells: Vec<Cell>, time: f32) -> Vec<Cell> {
        let mut cell_vec: Vec<Cell> = Vec::new();
        let mut cell_map: HashMap<u16, Cell> = HashMap::new();

        // This loop iterates over the cells, and adds them to a hashmap.
        // The hashmap is used to combine the cells that have moved to the same location.
        // The next loop iterates over the hashmap, and adds the cells to the new_cells vector.
        for (index, cell) in cells.iter().enumerate() {
            let (row, col) = self.index_to_row_col(index as u16);

            // break the acceleration into x and y components
            let acc_x = cell.accel_magnitude * cell.accel_degrees.to_radians().cos();
            let acc_y = cell.accel_magnitude * cell.accel_degrees.to_radians().sin();

            // modify the acceleration by the time, to enable faster or slower movement
            let new_x = (acc_x * time.powf(2.0)) as i16 + col as i16;
            let new_y = (acc_y * time.powf(2.0)) as i16 + row as i16;

            // clamp x and y to the edges of the galaxy
            let new_x = self.clamp(new_x, 0, self.size - 1);
            let new_y = self.clamp(new_y, 0, self.size - 1);
            let new_index = self.col_row_to_index(new_x, new_y);

            // get mass of the cell at the new index
            let existing_cell = cell_map.get(&new_index).unwrap_or(&Cell {
                mass: 0,
                accel_magnitude: 0.0,
                accel_degrees: 0.0,
            });
            let new_mass = existing_cell.mass + cell.mass;

            // add the cell to the map
            cell_map.insert(
                new_index,
                Cell {
                    mass: new_mass,
                    accel_magnitude: 0.0,
                    accel_degrees: 0.0,
                },
            );
        }

        // iterate over the size of the galaxy
        // adding the cells from the hashmap to the new_cells vector
        for index in 0..self.size.pow(2) {
            let cell = cell_map
                .get(&index)
                .unwrap_or(&Cell {
                    mass: 0,
                    accel_magnitude: 0.0,
                    accel_degrees: 0.0,
                })
                .clone();
            cell_vec.push(cell);
        }

        return cell_vec;
    }
    fn clamp(&self, value: i16, min: u16, max: u16) -> u16 {
        if value < (min as i16) {
            return max - (value.abs() as u16 % max);
        } else if value > (max as i16) {
            return value as u16 % max;
        } else {
            return value.abs() as u16;
        }
    }
}

// private methods - the methods needed for gravitation
impl Galaxy {
    fn gravitate(&self, index: u16, neighbours: Vec<(u16, u16)>) -> (f32, f32) {
        let mut sum_accel_magnitude = self.cells[index as usize].accel_magnitude;
        let mut sum_accel_degrees = self.cells[index as usize].accel_degrees;
        for neighbour_coords in neighbours {
            let (new_accel_magnitude, new_accel_degrees) =
                self.acceleration(index, neighbour_coords);
            (sum_accel_magnitude, sum_accel_degrees) = self.combine_vectors(
                sum_accel_magnitude,
                sum_accel_degrees,
                new_accel_magnitude,
                new_accel_degrees,
            );
        }
        return (sum_accel_magnitude, sum_accel_degrees);
    }
    fn combine_vectors(
        &self,
        init_magnitude: f32,
        init_degrees: f32,
        new_magnitude: f32,
        new_degrees: f32,
    ) -> (f32, f32) {
        let init_x = init_magnitude * init_degrees.to_radians().cos();
        let init_y = init_magnitude * init_degrees.to_radians().sin();
        let new_x = new_magnitude * new_degrees.to_radians().cos();
        let new_y = new_magnitude * new_degrees.to_radians().sin();
        let x = init_x + new_x;
        let y = init_y + new_y;
        let magnitude = (x.powi(2) + y.powi(2)).sqrt();
        let degrees = (x.atan2(y)).to_degrees();
        return (magnitude, degrees);
    }
    fn acceleration(&self, index: u16, neighbour_coords: (u16, u16)) -> (f32, f32) {
        let cell = self.cells[index as usize];
        let neighbour_index = self.col_row_to_index(neighbour_coords.0, neighbour_coords.1);
        let neighbour_cell = self.cells[neighbour_index as usize];
        let distance = self.distance(index, neighbour_coords);
        let degrees = self.degrees(index, neighbour_coords);
        let gravitation = self.gravitation(cell.mass, neighbour_cell.mass, distance);
        let acceleration = gravitation / cell.mass as f32;
        return (acceleration, degrees);
    }
    fn gravitation(&self, mass_one: u16, mass_two: u16, distance: f32) -> f32 {
        // https://en.wikipedia.org/wiki/Newton%27s_law_of_universal_gravitation
        // F = G * ((m1 * m2) / r^2)
        let force =
            Galaxy::GRAVATIONAL_CONSTANT * ((mass_one * mass_two) as f32 / distance.powi(2));
        return force;
    }
    fn degrees(&self, index: u16, neighbour_coords: (u16, u16)) -> f32 {
        let (cell_x, cell_y) = self.index_to_row_col(index);
        let x = neighbour_coords.0 as i16 - cell_x as i16;
        let y = neighbour_coords.1 as i16 - cell_y as i16;
        let radians = (x as f32).atan2(y as f32);
        let degrees = radians.to_degrees();
        return degrees;
    }
    fn distance(&self, index: u16, neighbour_coords: (u16, u16)) -> f32 {
        let (cell_x, cell_y) = self.index_to_row_col(index);
        let x = (cell_x as i16 - neighbour_coords.0 as i16).pow(2);
        let y = (cell_y as i16 - neighbour_coords.1 as i16).pow(2);
        let distance = (x as f32 + y as f32).sqrt();
        return distance;
    }
}

#[cfg(test)]
mod tests_combine_vectors {}

#[cfg(test)]
mod tests_distance {
    use super::*;
    #[test]
    fn test_distance_one() {
        let galaxy = Galaxy::new(3, 0, 1000);
        let index: u16 = 0;
        let neighbour_coords = (1, 1);
        let mut distance = galaxy.distance(index, neighbour_coords);
        distance = (distance * 100.0).round() / 100.0;
        assert_eq!(distance, 1.41);
    }
    #[test]
    fn test_distance_two() {
        let galaxy = Galaxy::new(3, 0, 1000);
        let index = 0;
        let neighbour_coords = (2, 2);
        let mut distance = galaxy.distance(index, neighbour_coords);
        distance = (distance * 100.0).round() / 100.0;
        assert_eq!(distance, 2.83);
    }
    #[test]
    fn test_distance_two_linear() {
        let galaxy = Galaxy::new(3, 0, 1000);
        let index = 0;
        let neighbour_coords = (0, 2);
        let mut distance = galaxy.distance(index, neighbour_coords);
        distance = (distance * 100.0).round() / 100.0;
        assert_eq!(distance, 2.00);
    }
}

mod tests_degreess {
    use super::*;
    #[test]
    fn test_degreess_x() {
        let galaxy = Galaxy::new(3, 0, 1000);
        let index = 0;
        let neighbour_coords = (2, 0);
        let degrees = galaxy.degrees(index, neighbour_coords).round() as u16;
        assert_eq!(degrees, 90, "neighbour_coords: {:?}, x", neighbour_coords);
    }
    #[test]
    fn test_degreess_y() {
        let galaxy = Galaxy::new(3, 0, 1000);
        let index = 0;
        let neighbour_coords = (0, 2);
        let degrees = galaxy.degrees(index, neighbour_coords).round() as u16;
        assert_eq!(degrees, 0, "neighbour_coords: {:?}, y", neighbour_coords);
    }
    #[test]
    fn test_degreess_z_one() {
        let galaxy = Galaxy::new(3, 0, 1000);
        let index = 0;
        let neighbour_coords = (2, 2);
        let degrees = galaxy.degrees(index, neighbour_coords).round() as u16;
        assert_eq!(degrees, 45, "neighbour_coords: {:?}, xy", neighbour_coords);
    }
    #[test]
    fn test_degreess_z_two() {
        let galaxy = Galaxy::new(3, 0, 1000);
        let index = 0;
        let neighbour_coords = (1, 2);
        let degrees = galaxy.degrees(index, neighbour_coords).round() as u16;
        assert_eq!(degrees, 27, "neighbour_coords: {:?}, xy", neighbour_coords);
    }
    #[test]
    fn test_degreess_z_three() {
        let galaxy = Galaxy::new(3, 0, 1000);
        let index = 0;
        let neighbour_coords = (2, 1);
        let degrees = galaxy.degrees(index, neighbour_coords).round() as u16;
        assert_eq!(degrees, 63, "neighbour_coords: {:?}, xy", neighbour_coords);
    }
}

#[cfg(test)]
mod tests_intial_generation {
    use super::*;
    #[test]
    fn test_inital_generation_no_panic() {
        Galaxy::new(10, 0, 1000);
    }
    #[test]
    fn test_seed_no_panic() {
        Galaxy::new(10, 0, 1000).seed(1);
    }
    #[test]
    fn test_seed_tick_no_panic() {
        Galaxy::new(10, 1, 1000).seed(1).tick(1.0);
    }
    #[test]
    fn test_seed_alters_data() {
        let mut galaxy = Galaxy::new(10, 0, 1000);
        let cells_before = galaxy.cells.clone();
        galaxy = galaxy.seed(1);
        let cells_after = galaxy.cells.clone();
        assert_ne!(cells_before, cells_after);
    }
    #[test]
    fn test_seed_doesnt_alter_when_zero() {
        let mut galaxy = Galaxy::new(10, 0, 1000);
        let cells_before = galaxy.cells.clone();
        galaxy = galaxy.seed(0);
        let cells_after = galaxy.cells.clone();
        assert_eq!(cells_before, cells_after);
    }
    #[test]
    fn test_seed_alters_data_twice() {
        let mut galaxy = Galaxy::new(10, 0, 1000);
        let cells_first = galaxy.cells.clone();

        galaxy = galaxy.seed(1);
        let cells_second = galaxy.cells.clone();
        assert_ne!(cells_first, cells_second);

        galaxy = galaxy.seed(1);
        let cells_third = galaxy.cells.clone();
        assert_ne!(cells_first, cells_second);
        assert_ne!(cells_first, cells_third);
        assert_ne!(cells_second, cells_third);
    }
}

#[cfg(test)]
mod tests_indexing {
    use super::*;
    #[test]
    fn test_index_to_row_col_start() {
        let galaxy = Galaxy::new(3, 0, 1000);
        assert_eq!(galaxy.index_to_row_col(0), (0, 0));
    }
    #[test]
    fn test_col_row_to_index_start() {
        let galaxy = Galaxy::new(3, 0, 1000);
        assert_eq!(galaxy.col_row_to_index(0, 0), 0);
    }
    #[test]
    fn test_index_to_row_col_center() {
        let galaxy = Galaxy::new(3, 0, 1000);
        assert_eq!(galaxy.index_to_row_col(4), (1, 1));
    }
    #[test]
    fn test_col_row_to_index_center() {
        let galaxy = Galaxy::new(3, 0, 1000);
        assert_eq!(galaxy.col_row_to_index(1, 1), 4);
    }
    #[test]
    fn test_index_to_row_col_end() {
        let galaxy = Galaxy::new(3, 0, 1000);
        assert_eq!(galaxy.index_to_row_col(8), (2, 2));
    }
    #[test]
    fn test_col_row_to_index_end() {
        let galaxy = Galaxy::new(3, 0, 1000);
        assert_eq!(galaxy.col_row_to_index(2, 2), 8);
    }
    #[test]
    fn index_to_row_col_first() {
        let galaxy = Galaxy::new(3, 0, 1000);
        let index = 1;
        let (x, y) = galaxy.index_to_row_col(index);
        assert_eq!(x, 1);
        assert_eq!(y, 0);
    }
    #[test]
    fn index_to_row_col_second() {
        let galaxy = Galaxy::new(3, 0, 1000);
        let index = 2;
        let (x, y) = galaxy.index_to_row_col(index);
        assert_eq!(x, 2);
        assert_eq!(y, 0);
    }
    #[test]
    fn test_index_edge_transform_top_right() {
        let galaxy = Galaxy::new(3, 0, 1000);
        let index = 2;
        let (x, y) = galaxy.index_to_row_col(index);
        assert_eq!(galaxy.col_row_to_index(x, y), index);
        assert_eq!(x, 2);
        assert_eq!(y, 0);
    }
    #[test]
    fn test_index_edge_transform_bottom_left() {
        let galaxy = Galaxy::new(3, 0, 1000);
        let index = 6;
        let (x, y) = galaxy.index_to_row_col(index);
        assert_eq!(galaxy.col_row_to_index(x, y), index);
        assert_eq!(x, 0);
        assert_eq!(y, 2);
    }
}

#[cfg(test)]
mod tests_neighbors_and_reach {
    use super::*;
    #[test]
    fn test_mass() {
        let galaxy = Galaxy::new(3, 0, 1000);
        assert_eq!(galaxy.mass(), vec![0, 0, 0, 0, 0, 0, 0, 0, 0]);
    }
    #[test]
    fn test_x() {
        let galaxy = Galaxy::new(3, 0, 1000);
        assert_eq!(galaxy.x(), vec![0, 1, 2, 0, 1, 2, 0, 1, 2]);
    }
    #[test]
    fn test_y() {
        let galaxy = Galaxy::new(3, 0, 1000);
        assert_eq!(galaxy.y(), vec![0, 0, 0, 1, 1, 1, 2, 2, 2]);
    }
    #[test]
    fn test_reach_range_start_edge() {
        let galaxy = Galaxy::new(3, 0, 1000);
        assert_eq!(galaxy.reach_range_start(0, 99), 0);
    }
    #[test]
    fn test_reach_range_start_overflow() {
        let galaxy = Galaxy::new(3, 0, 1000);
        assert_eq!(galaxy.reach_range_start(1, 99), 0);
    }
    #[test]
    fn test_reach_range_start_contained() {
        let galaxy = Galaxy::new(10, 0, 1000);
        assert_eq!(galaxy.reach_range_start(4, 2), 2);
    }
    #[test]
    fn test_reach_range_end_edge() {
        let galaxy = Galaxy::new(3, 0, 1000);
        assert_eq!(galaxy.reach_range_end(2, 99), 2);
    }
    #[test]
    fn test_reach_range_end_overflow() {
        let galaxy = Galaxy::new(3, 0, 1000);
        assert_eq!(galaxy.reach_range_end(0, 99), 2);
    }
    #[test]
    fn test_reach_range_end_contained() {
        let galaxy = Galaxy::new(10, 0, 1000);
        assert_eq!(galaxy.reach_range_end(2, 2), 4);
    }
    #[test]
    fn test_neighbor_size() {
        let galaxy = Galaxy::new(10, 0, 1000);
        assert_eq!(galaxy.neighbours(0, 1).len(), 3);
    }
    #[test]
    fn test_neighbor_size_larger() {
        let galaxy = Galaxy::new(10, 0, 1000);
        assert_eq!(galaxy.neighbours(0, 2).len(), 8);
        assert_eq!(galaxy.neighbours(0, u16::MAX).len(), 99);
    }
    #[test]
    fn test_neighbor_size_center() {
        let galaxy = Galaxy::new(3, 0, 1000);
        assert_eq!(galaxy.neighbours(4, 1).len(), 8);
        assert_eq!(galaxy.neighbours(4, u16::MAX).len(), 8);
    }
    #[test]
    fn test_neighbor_size_differs_for_large_galaxy() {
        let mut galaxy = Galaxy::new(100, 0, 1000);
        let index = 0 as usize;
        // gas
        galaxy.cells[index] = Cell {
            mass: 1,
            accel_magnitude: 0.0,
            accel_degrees: 0.0,
        };
        let gas_neighbours = galaxy.neighbours_of_my_type(0).len();
        // star
        galaxy.cells[index] = Cell {
            mass: 65535,
            accel_magnitude: 0.0,
            accel_degrees: 0.0,
        };
        let star_neighbours = galaxy.neighbours_of_my_type(0).len();
        assert_ne!(gas_neighbours, star_neighbours);
    }
    #[test]
    fn test_neighbor_size_same_for_small_galaxy() {
        let mut galaxy = Galaxy::new(1, 0, 1000);
        let index = 0 as usize;
        // gas
        galaxy.cells[index] = Cell {
            mass: 1,
            accel_magnitude: 0.0,
            accel_degrees: 0.0,
        };
        let gas_neighbours = galaxy.neighbours_of_my_type(0).len();
        // star
        galaxy.cells[index] = Cell {
            mass: 59999,
            accel_magnitude: 0.0,
            accel_degrees: 0.0,
        };
        let star_neighbours = galaxy.neighbours_of_my_type(0).len();
        assert_eq!(gas_neighbours, star_neighbours);
    }
}
